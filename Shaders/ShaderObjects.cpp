#include "ShaderObjects.hpp"
#include "../MachineInfo.hpp"
#include "../Utils/Debug.hpp"
#include "../Utils/Log.hpp"
#include "ShaderConfig.hpp"
#include "ShaderUniforms.hpp"

#ifndef __glew_h__
#   include <GL\glew.h>
#endif

namespace MR {

/** SHADER CLASS **/

bool Shader::Attach(IShaderProgram* program) {
    AssertExec(!program, MR::Log::LogString("Error in Shader::Attach : program == nullptr.", MR_LOG_LEVEL_ERROR))

    //for gl error handling
#ifdef MR_CHECK_SMALL_GL_ERRORS
    int gl_er = 0;
    MR::MachineInfo::ClearError();
#endif

    glAttachShader(program->GetGPUHandle(), _gpu_handle);

    //if glAttachShader is failed
#ifdef MR_CHECK_SMALL_GL_ERRORS
    if(MR::MachineInfo::CatchError(0, &gl_er)) {
        std::string err_str = "Error in Shader::Attach : glAttachShader ended with \"" + std::to_string(gl_er) + "\" code. ";
        switch(gl_er) {
        case GL_INVALID_VALUE:
            err_str += "Shader id or program id is not generated by OpenGL values."; break;
        case GL_INVALID_OPERATION:
            err_str += "Shader id is not shader or program id is not program or this shader is already attached or other shader of this type is already attached."; break;
        default:
            err_str += "Unknow code."; break;
        }
        MR::Log::LogString(err_str, MR_LOG_LEVEL_ERROR);
        return false;
    }
#endif

    _connected.push_back(program);

    return true;
}

void Shader::Detach(IShaderProgram* program) {
    AssertExec(!program, MR::Log::LogString("Error in Shader::Detach : program == nullptr.", MR_LOG_LEVEL_ERROR))

    //for gl error handling
#ifdef MR_CHECK_SMALL_GL_ERRORS
    int gl_er = 0;
    MR::MachineInfo::ClearError();
#endif

    glDetachShader(program->GetGPUHandle(), _gpu_handle);

    //if glDetachShader is failed
#ifdef MR_CHECK_SMALL_GL_ERRORS
    if(MR::MachineInfo::CatchError(0, &gl_er)) {
        std::string err_str = "Error in Shader::Detach : glDetachShader ended with \"" + std::to_string(gl_er) + "\" code. ";
        switch(gl_er) {
        case GL_INVALID_VALUE:
            err_str += "Shader id or program id is not generated by OpenGL values."; break;
        case GL_INVALID_OPERATION:
            err_str += "Shader id is not shader or program id is not program or this shader is not attached."; break;
        default:
            err_str += "Unknow code."; break;
        }
        MR::Log::LogString(err_str, MR_LOG_LEVEL_ERROR);
    }
#endif

    auto it = std::find(_connected.begin(), _connected.end(), program);
    if(it != _connected.end()) _connected.erase(it);
}

StaticArray<IShaderProgram*> Shader::GetConnectedPrograms() {
    if(_connected.size() != 0) return StaticArray<IShaderProgram*>(&_connected[0], _connected.size());
    else return StaticArray<IShaderProgram*>();
}

void Shader::Destroy() {
    if(_gpu_handle != 0) {
        while(_connected.size() != 0) {
            Detach(_connected[0]);
        }

        glDeleteShader(_gpu_handle);
        _gpu_handle = 0;
    }
}

Shader::Shader
(const unsigned int& gpu_handle, const IShader::Type& type)
: _type(type), _gpu_handle(gpu_handle), _connected() {
}

Shader::~Shader() {
}

Shader* Shader::Create(const IShader::Type& type) {

    //for gl error handling
    int gl_er = 0;
    MR::MachineInfo::ClearError();

    unsigned int gpu_h = glCreateShader(type);

    //if glCreateShader is failed
#ifdef MR_CHECK_LARGE_GL_ERRORS
    if(MR::MachineInfo::CatchError(0, &gl_er)) {
        std::string err_str = "Error in Shader::CreateShader : glCreateShader ended with \"" + std::to_string(gl_er) + "\" code. ";
        switch(gl_er) {
        case GL_INVALID_ENUM:
            err_str += "shaderType is not an accepted value."; break;
        default:
            err_str += "Unknow code."; break;
        }
        MR::Log::LogString(err_str, MR_LOG_LEVEL_ERROR);
        return nullptr;
    }
#endif // MR_CHECK_LARGE_GL_ERRORS

    Shader* sh = new Shader(gpu_h, type);
    return sh;
}

/** SHADER PROGRAM **/

bool ShaderProgram::BindDefaultShaderInOut() {
    AssertExec(!_program, MR::Log::LogString("Error in ShaderProgram::BindDefaultShaderInOut : _program == 0.", MR_LOG_LEVEL_ERROR); return false)

    MR::MachineInfo::ClearError();

    bool status = true;
    std::string errorStr = "";

    glBindAttribLocation(_program, MR_SHADER_VERTEX_POSITION_ATTRIB_LOCATION, MR_SHADER_VERTEX_POSITION_ATTRIB_NAME);

    if(MR::MachineInfo::CatchError(&errorStr, NULL)){
        MR::Log::LogString("Error while binding vertex position shader's attribute \""+errorStr+"\"", MR_LOG_LEVEL_ERROR);
        status = false;
    }

    glBindAttribLocation(_program, MR_SHADER_VERTEX_NORMAL_ATTRIB_LOCATION, MR_SHADER_VERTEX_NORMAL_ATTRIB_NAME);

    if(MR::MachineInfo::CatchError(&errorStr, NULL)){
        MR::Log::LogString("Error while binding vertex normal shader's attribute \""+errorStr+"\"", MR_LOG_LEVEL_ERROR);
        status = false;
    }

    glBindAttribLocation(_program, MR_SHADER_VERTEX_COLOR_ATTRIB_LOCATION, MR_SHADER_VERTEX_COLOR_ATTRIB_NAME);

    if(MR::MachineInfo::CatchError(&errorStr, NULL)){
        MR::Log::LogString("Error while binding vertex color shader's attribute \""+errorStr+"\"", MR_LOG_LEVEL_ERROR);
        status = false;
    }

    glBindAttribLocation(_program, MR_SHADER_VERTEX_TEXCOORD_ATTRIB_LOCATION, MR_SHADER_VERTEX_TEXCOORD_ATTRIB_NAME);

    if(MR::MachineInfo::CatchError(&errorStr, NULL)){
        MR::Log::LogString("Error while binding vertex texcoord shader's attribute \""+errorStr+"\"", MR_LOG_LEVEL_ERROR);
        status = false;
    }

    glBindFragDataLocation(_program, MR_SHADER_DEFAULT_FRAG_DATA_LOCATION_1, MR_SHADER_DEFAULT_FRAG_DATA_NAME_1);

    if(MR::MachineInfo::CatchError(&errorStr, NULL)){
        MR::Log::LogString("Error while binding shader's frag data output \""+errorStr+"\"", MR_LOG_LEVEL_ERROR);
        status = false;
    }

    glBindFragDataLocation(_program, MR_SHADER_DEFAULT_FRAG_DATA_LOCATION_2, MR_SHADER_DEFAULT_FRAG_DATA_NAME_2);
    glBindFragDataLocation(_program, MR_SHADER_DEFAULT_FRAG_DATA_LOCATION_3, MR_SHADER_DEFAULT_FRAG_DATA_NAME_3);

    return status;
}

ShaderProgram* ShaderProgram::Create() {
    //for gl error handling
    MR::MachineInfo::ClearError();

    unsigned int gpu_h = glCreateProgram();
    if(gpu_h == 0) {
        MR::Log::LogString("Error in ShaderProgram::Create : glCreateProgram returned 0.", MR_LOG_LEVEL_ERROR);
        return nullptr;
    }

    ShaderProgram* sh = new ShaderProgram(gpu_h, IShaderProgram::Features());
    return sh;
}

IShaderUniform* ShaderProgram::CreateUniform(const std::string& name, const MR::IShaderUniform::Type& type, void* value) {
    ShaderUniform* su = new ShaderUniform(name, type, value, dynamic_cast<IShaderProgram*>(this));
    _shaderUniforms.push_back(su);
    return su;
}

void ShaderProgram::SetUniform(const std::string& name, const int& value) {
    if(_program) {
        if(MR::MachineInfo::IsDirectStateAccessSupported()) glProgramUniform1i(_program, glGetUniformLocation(_program, name.c_str()), value);
        else glUniform1i(glGetUniformLocation(_program, name.c_str()), value);
    }
}

void ShaderProgram::SetUniform(const std::string& name, const float& value) {
    if(_program) {
        if(MR::MachineInfo::IsDirectStateAccessSupported()) glProgramUniform1f(_program, glGetUniformLocation(_program, name.c_str()), value);
        else glUniform1f(glGetUniformLocation(_program, name.c_str()), value);
    }
}

void ShaderProgram::SetUniform(const std::string& name, const glm::vec2& value) {
    if(_program) {
        if(MR::MachineInfo::IsDirectStateAccessSupported()) glProgramUniform2fv(_program, glGetUniformLocation(_program, name.c_str()), 2, &value.x);
        else glUniform2fv(glGetUniformLocation(_program, name.c_str()), 2, &value.x);
    }
}

void ShaderProgram::SetUniform(const std::string& name, const glm::vec3& value) {
    if(_program) {
        if(MR::MachineInfo::IsDirectStateAccessSupported()) glProgramUniform3fv(_program, glGetUniformLocation(_program, name.c_str()), 3, &value.x);
        else glUniform3fv(glGetUniformLocation(_program, name.c_str()), 3, &value.x);
    }
}

void ShaderProgram::SetUniform(const std::string& name, const glm::vec4& value) {
    if(_program) {
        if(MR::MachineInfo::IsDirectStateAccessSupported()) glProgramUniform4fv(_program, glGetUniformLocation(_program, name.c_str()), 4, &value.x);
        else glUniform4fv(glGetUniformLocation(_program, name.c_str()), 4, &value.x);
    }
}

void ShaderProgram::SetUniform(const std::string& name, const glm::mat4& value) {
    if(_program) {
        if(MR::MachineInfo::IsDirectStateAccessSupported()) glProgramUniformMatrix4fv(_program, glGetUniformLocation(_program, name.c_str()), 1,  GL_FALSE, &value[0][0]);
        else glUniformMatrix4fv(glGetUniformLocation(_program, name.c_str()), 1,  GL_FALSE, &value[0][0]);
    }
}

void ShaderProgram::DeleteUniform(IShaderUniform* su) {
    auto it = std::find(_shaderUniforms.begin(), _shaderUniforms.end(), su);
    if(it == _shaderUniforms.end()) return;
    delete (*it);
    _shaderUniforms.erase(it);
}

IShaderUniform* ShaderProgram::FindShaderUniform(const std::string& name) {
    for(size_t i = 0; i < _shaderUniforms.size(); ++i){
        if(_shaderUniforms[i]->GetName() == name) return _shaderUniforms[i];
    }
    return nullptr;
}

size_t ShaderProgram::GetShaderUniformsPtr(IShaderUniform*** list_ptr) {
    if(!list_ptr) return 0;
    *list_ptr = &_shaderUniforms[0];
    return _shaderUniforms.size();
}

StaticArray<ShaderUniformInfo> ShaderProgram::GetCompiledUniforms() {
    int act_uniforms = 0;
    glGetProgramiv(_program, GL_ACTIVE_UNIFORMS, &act_uniforms);
    if(act_uniforms == 0) return StaticArray<ShaderUniformInfo>();

    ShaderUniformInfo* uni = new ShaderUniformInfo[act_uniforms];

    for(int iu = 0; iu < act_uniforms; ++iu){
        char namebuffer[1024];
        int real_buf_size = 0;
        int unif_size = 0;
        unsigned int uni_type = 0;
        glGetActiveUniform(_program, iu, 1024, &real_buf_size, &unif_size, &uni_type, &namebuffer[0]);
        uni[iu] = ShaderUniformInfo(dynamic_cast<IShaderProgram*>(this), std::string(namebuffer), unif_size, uni_type);
    }

    return StaticArray<ShaderUniformInfo>(&uni[0], act_uniforms, false);
}

void ShaderProgram::Destroy() {
    if(_program != 0) {
        glDeleteProgram(_program);
        _program = 0;
    }
}

bool ShaderProgram::Use() {
    if(_program == 0) return false;
    glUseProgram(_program);
    UpdateUniforms();
    return true;
}

void ShaderProgram::UpdateUniforms() {
    for(size_t i = 0; i < _shaderUniforms.size(); ++i){
        if(_shaderUniforms[i]->GetPtr()) {
            if(MR::MachineInfo::IsDirectStateAccessSupported()) {
                switch(_shaderUniforms[i]->GetType()){
                case IShaderUniform::Type::SUT_Float:
                    glProgramUniform1f(_program, _shaderUniforms[i]->GetGPULocation(), *((float*)_shaderUniforms[i]->GetPtr()));
                    break;
                case IShaderUniform::Type::SUT_Sampler1D:
                case IShaderUniform::Type::SUT_Sampler2D:
                case IShaderUniform::Type::SUT_Sampler3D:
                case IShaderUniform::Type::SUT_Int:
                    glProgramUniform1i(_program, _shaderUniforms[i]->GetGPULocation(), *((int*)_shaderUniforms[i]->GetPtr()));
                    break;
                case IShaderUniform::Type::SUT_Mat4:
                    glProgramUniformMatrix4fv(_program, _shaderUniforms[i]->GetGPULocation(), 1, false, ((float*)_shaderUniforms[i]->GetPtr()));
                    break;
                case IShaderUniform::Type::SUT_Vec2:
                    glProgramUniform2fv(_program, _shaderUniforms[i]->GetGPULocation(), 1, ((float*)_shaderUniforms[i]->GetPtr()));
                    break;
                case IShaderUniform::Type::SUT_Vec3:
                    glProgramUniform3fv(_program, _shaderUniforms[i]->GetGPULocation(), 1, ((float*)_shaderUniforms[i]->GetPtr()));
                    break;
                case IShaderUniform::Type::SUT_Vec4:
                    glProgramUniform4fv(_program, _shaderUniforms[i]->GetGPULocation(), 1, ((float*)_shaderUniforms[i]->GetPtr()));
                    break;
                }
            } else {
                switch(_shaderUniforms[i]->GetType()){
                case IShaderUniform::Type::SUT_Float:
                    glUniform1f(_shaderUniforms[i]->GetGPULocation(), *((float*)_shaderUniforms[i]->GetPtr()));
                    break;
                case IShaderUniform::Type::SUT_Sampler1D:
                case IShaderUniform::Type::SUT_Sampler2D:
                case IShaderUniform::Type::SUT_Sampler3D:
                case IShaderUniform::Type::SUT_Int:
                    glUniform1i(_shaderUniforms[i]->GetGPULocation(), *((int*)_shaderUniforms[i]->GetPtr()));
                break;
                case IShaderUniform::Type::SUT_Mat4:
                    glUniformMatrix4fv(_shaderUniforms[i]->GetGPULocation(), 1, false, ((float*)_shaderUniforms[i]->GetPtr()));
                    break;
                case IShaderUniform::Type::SUT_Vec2:
                    glUniform2fv(_shaderUniforms[i]->GetGPULocation(), 1, ((float*)_shaderUniforms[i]->GetPtr()));
                    break;
                case IShaderUniform::Type::SUT_Vec3:
                    glUniform3fv(_shaderUniforms[i]->GetGPULocation(), 1, ((float*)_shaderUniforms[i]->GetPtr()));
                    break;
                case IShaderUniform::Type::SUT_Vec4:
                    glUniform4fv(_shaderUniforms[i]->GetGPULocation(), 1, ((float*)_shaderUniforms[i]->GetPtr()));
                    break;
                }
            }
        }
    }
}

ShaderProgram::ShaderProgram
(const unsigned int& gpu_program, const MR::IShaderProgram::Features& features)
: _program(gpu_program), _shaderUniforms(), _features(features) {
}

ShaderProgram::~ShaderProgram() {
}

}
