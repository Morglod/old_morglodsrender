#include "ShaderUniforms.hpp"
#include "../MachineInfo.hpp"
#include "../Utils/Log.hpp"
#include "../Utils/Debug.hpp"
#include "../StateCache.hpp"

#ifndef __glew_h__
#   include <GL\glew.h>
#endif

namespace mr {

ShaderUniformDesc::ShaderUniformDesc() : name("NoNameUniform"), type(IShaderUniformRef::Type::Float) {
}

ShaderUniformDesc::ShaderUniformDesc(std::string const& n, IShaderUniformRef::Type const& t) : name(n), type(t) {
}

ShaderUniformInfo::ShaderUniformInfo() : program(nullptr), name("NoNameUniform"), size(0), gl_type(0), location(-1) {
}

ShaderUniformInfo::ShaderUniformInfo(IShaderProgram* p, const std::string& n, const int& s, const unsigned int & t, int const& loc)
: program(p), name(n), size(s), gl_type(t), location(loc) {}


IShaderUniformRef* ShaderUniformMap::CreateRef(std::string const& name, mr::IShaderUniformRef::Type const& type, void* value) {
    if(!IsUniform(name)) return nullptr;

    ShaderUniformInfo* info = &_uniforms[name];
    if(info->value_ref != nullptr) {
        DeleteRef(name);
    }
    ShaderUniformRef* uref = new ShaderUniformRef(name, type, info->location, value, this);
    IShaderUniformRef* iuref = static_cast<IShaderUniformRef*>(uref);
    info->value_ref = iuref;
    _refs.insert(iuref);
    iuref->Update();
    return iuref;
}

void ShaderUniformMap::DeleteRef(std::string const& name) {
    if(!IsUniform(name)) return;

    ShaderUniformInfo* info = &_uniforms[name];
    if(info->value_ref == nullptr) return;

    _refs.erase(info->value_ref);
    delete info->value_ref;
    info->value_ref = nullptr;
}

IShaderUniformRef* ShaderUniformMap::FindRef(std::string const& name) {
    if(!IsUniform(name)) return nullptr;
    return _uniforms[name].value_ref;
}

mu::ArrayHandle<IShaderUniformRef*> ShaderUniformMap::GetRefs() {
    IShaderUniformRef** refs = new IShaderUniformRef*[_refs.size()];
    size_t i = 0;
    for(IShaderUniformRef* ur : _refs) {
        refs[i] = ur;
        ++i;
    }
    return mu::ArrayHandle<IShaderUniformRef*>(refs, _refs.size(), true, false);
}

mu::ArrayHandle<ShaderUniformInfo> ShaderUniformMap::GetCompiledUniforms() {
    ShaderUniformInfo* info = new ShaderUniformInfo[_uniforms.size()];
    size_t i = 0;
    for(auto const& inf_pair : _uniforms) {
        info[i] = inf_pair.second;
        ++i;
    }
    return mu::ArrayHandle<ShaderUniformInfo>(info, _uniforms.size(), true, false);
}

bool ShaderUniformMap::IsUniform(std::string const& uniformName) {
    return (_uniforms.count(uniformName) != 0);
}

int ShaderUniformMap::GetUniformGPULocation(std::string const& uniformName) {
    if(!IsUniform(uniformName)) return -1;
    if(_uniforms[uniformName].location == -1) {
        if(!_GetUniformGPULocation(uniformName, &(_uniforms[uniformName].location))) {
            mr::Log::LogString("Failed ShaderUniformMap::GetUniformGPULocation.", MR_LOG_LEVEL_ERROR);
        }
    }
    return _uniforms[uniformName].location;
}

void ShaderUniformMap::DeleteAllRefs() {
    while(!_refs.empty()) {
        DeleteRef((*(_refs.begin()))->GetName());
    }
}

bool ShaderUniformMap::_GetUniformGPULocation(std::string const& uniformName, int* out) {
#ifdef MR_CHECK_SMALL_GL_ERRORS
    int gl_er = 0;
    mr::MachineInfo::ClearError();
#endif

    *out = glGetUniformLocation(_program->GetGPUHandle(), uniformName.c_str());

#ifdef MR_CHECK_SMALL_GL_ERRORS
    if(mr::MachineInfo::CatchError(0, &gl_er)) {
        std::string err_str = "Error in ShaderUniformMap::_GetUniformGPULocation : glGetUniformLocation("+std::to_string(_program->GetGPUHandle())+", \""+uniformName+"\") ended with \"" + std::to_string(gl_er) + "\" code. ";
        switch(gl_er) {
        case GL_INVALID_VALUE:
            err_str += "Shader program id is not generated by OpenGL values."; break;
        case GL_INVALID_OPERATION:
            err_str += "id is not an OpenGL program object or program is not successfully linked."; break;
        default:
            err_str += "Unknow code."; break;
        }
        mr::Log::LogString(err_str, MR_LOG_LEVEL_ERROR);
        return false;
    }
#endif

    if((*out) == -1) {
#ifdef MR_CHECK_SMALL_GL_ERRORS
        mr::Log::LogString("Error in ShaderUniformMap::_GetUniformGPULocation : glGetUniformLocation("+std::to_string(_program->GetGPUHandle())+", \""+uniformName+"\") == -1.", MR_LOG_LEVEL_ERROR);
#endif
        return false;
    }

    return true;
}

void ShaderUniformMap::SetUniform(int const& location, int const& value) {
    if(GLEW_EXT_direct_state_access) glProgramUniform1i(_program->GetGPUHandle(), location, value);
    else {
        StateCache* cache = StateCache::GetDefault();
        IShaderProgram* was = nullptr;
        if(cache->ReSetShaderProgram(_program, &was)) {
            glUniform1i(location, value);
        } else {
            mr::Log::LogString("Failed ShaderUniformMap::SetUniform. Failed set shader program.", MR_LOG_LEVEL_ERROR);
        }
        cache->SetShaderProgram(_program);
    }
}

void ShaderUniformMap::SetUniform(int const& location, float const& value) {
    if(GLEW_EXT_direct_state_access) glProgramUniform1f(_program->GetGPUHandle(), location, value);
    else {
        StateCache* cache = StateCache::GetDefault();
        IShaderProgram* was = nullptr;
        if(cache->ReSetShaderProgram(_program, &was)) {
            glUniform1f(location, value);
        } else {
            mr::Log::LogString("Failed ShaderUniformMap::SetUniform. Failed set shader program.", MR_LOG_LEVEL_ERROR);
        }
        cache->SetShaderProgram(_program);
    }
}

void ShaderUniformMap::SetUniform(int const& location, glm::vec2 const& value) {
    if(GLEW_EXT_direct_state_access) glProgramUniform2fv(_program->GetGPUHandle(), location, 1, &value.x);
    else {
        StateCache* cache = StateCache::GetDefault();
        IShaderProgram* was = nullptr;
        if(cache->ReSetShaderProgram(_program, &was)) {
            glUniform2fv(location, 1, &value.x);
        } else {
            mr::Log::LogString("Failed ShaderUniformMap::SetUniform. Failed set shader program.", MR_LOG_LEVEL_ERROR);
        }
        cache->SetShaderProgram(_program);
    }
}

void ShaderUniformMap::SetUniform(int const& location, glm::vec3 const& value) {
    if(GLEW_EXT_direct_state_access) glProgramUniform3fv(_program->GetGPUHandle(), location, 1, &value.x);
    else {
        StateCache* cache = StateCache::GetDefault();
        IShaderProgram* was = nullptr;
        if(cache->ReSetShaderProgram(_program, &was)) {
            glUniform3fv(location, 1, &value.x);
        } else {
            mr::Log::LogString("Failed ShaderUniformMap::SetUniform. Failed set shader program.", MR_LOG_LEVEL_ERROR);
        }
        cache->SetShaderProgram(_program);
    }
}

void ShaderUniformMap::SetUniform(int const& location, glm::vec4 const& value) {
    if(GLEW_EXT_direct_state_access) glProgramUniform4fv(_program->GetGPUHandle(), location, 1, &value.x);
    else {
        StateCache* cache = StateCache::GetDefault();
        IShaderProgram* was = nullptr;
        if(cache->ReSetShaderProgram(_program, &was)) {
            glUniform4fv(location, 1, &value.x);
        } else {
            mr::Log::LogString("Failed ShaderUniformMap::SetUniform. Failed set shader program.", MR_LOG_LEVEL_ERROR);
        }
        cache->SetShaderProgram(_program);
    }
}

void ShaderUniformMap::SetUniform(int const& location, glm::mat4 const& value) {
    if(GLEW_EXT_direct_state_access) glProgramUniformMatrix4fv(_program->GetGPUHandle(), location, 1, false, &value[0][0]);
    else {
        StateCache* cache = StateCache::GetDefault();
        IShaderProgram* was = nullptr;
        if(cache->ReSetShaderProgram(_program, &was)) {
            glUniformMatrix4fv(location, 1, false, &value[0][0]);
        } else {
            mr::Log::LogString("Failed ShaderUniformMap::SetUniform. Failed set shader program.", MR_LOG_LEVEL_ERROR);
        }
        cache->SetShaderProgram(_program);
    }
}

void ShaderUniformMap::Reset(bool saveRefs) {
    unsigned int handle = _program->GetGPUHandle();
    int act_uniforms = 0;
    glGetProgramiv(handle, GL_ACTIVE_UNIFORMS, &act_uniforms);
    if(act_uniforms == 0) {
        if(!saveRefs) DeleteAllRefs();
        _uniforms.clear();
    }

    for(int iu = 0; iu < act_uniforms; ++iu){
        char namebuffer[1024];
        int real_buf_size = 0;
        int unif_size = 0;
        unsigned int uni_type = 0;
        glGetActiveUniform(handle, iu, 1024, &real_buf_size, &unif_size, &uni_type, &namebuffer[0]);
        std::string name(namebuffer);
        int location = -1;
        if(!_GetUniformGPULocation(name, &location)) {
            mr::Log::LogString("Failed ShaderUniformMap::Reset. Failed get uniform gpu location for \""+name+"\".", MR_LOG_LEVEL_ERROR);
            location = -1;
        }
        _uniforms[name] =  ShaderUniformInfo(dynamic_cast<IShaderProgram*>(this), name, unif_size, uni_type, location);
    }

    //remap refs
    if(saveRefs) {
        std::unordered_set<IShaderUniformRef*> refs = _refs;
        _refs.clear();
        for(IShaderUniformRef* r : refs) {
            if(IsUniform(r->GetName())) {
                void* value = r->GetValuePtr();
                IShaderUniformRef::Type type = r->GetType();
                std::string name = r->GetName();
                CreateRef(name, type, value);
            }
        }
        std::unordered_set<IShaderUniformRef*> tmp = _refs;
        _refs = refs;
        DeleteAllRefs();
        _refs = tmp;
    }
}

void ShaderUniformMap::UpdateRefs() {
    for(IShaderUniformRef* uref : _refs) {
        void* value = uref->GetValuePtr();
        if(value) {
#ifdef MR_CHECK_SMALL_GL_ERRORS
            int gl_er = 0;
            mr::gl::ClearError();
#endif
            uref->Update();
#ifdef MR_CHECK_SMALL_GL_ERRORS
            if(mr::MachineInfo::CatchError(0, &gl_er)) {
                std::string err_str = "Error in ShaderUniformMap::Update GL \""+ std::to_string(gl_er) + "\" code. ";
                switch(gl_er) {
                case GL_INVALID_VALUE:
                    err_str += "Uniform's data is less than zero."; break;
                case GL_INVALID_OPERATION:
                    err_str += "No current shader program or uniforms size doesn't match or uniforms type doesn't match or invalid uniform location or bad sampler."; break;
                default:
                    err_str += "Unknow code."; break;
                }
                mr::Log::LogString(err_str, MR_LOG_LEVEL_ERROR);
            }
#endif
        }
    }
}

ShaderUniformMap::ShaderUniformMap(IShaderProgram* program) : _program(program) {
}

void ShaderUniformRef::Update() {}
ShaderUniformRef::ShaderUniformRef(std::string const&, IShaderUniformRef::Type const&, int const& ,void*, ShaderUniformMap*) {
}

ShaderUniformRef::~ShaderUniformRef() {
}

}
