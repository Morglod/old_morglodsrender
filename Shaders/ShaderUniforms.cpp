#include "ShaderUniforms.hpp"
#include "../MachineInfo.hpp"
#include "../Utils/Log.hpp"
#include "../Utils/Debug.hpp"

#ifndef __glew_h__
#   include <GL\glew.h>
#endif

namespace mr {

bool ShaderUniform::ResetLocation() {
    AssertExec(_owner != nullptr, mr::Log::LogString("Error in ShaderUniform::ResetLocation : program == nullptr.", MR_LOG_LEVEL_ERROR))

#ifdef MR_CHECK_SMALL_GL_ERRORS
    int gl_er = 0;
    mr::MachineInfo::ClearError();
#endif

    _gpu_location = glGetUniformLocation(_owner->GetGPUHandle(), _name.c_str());

#ifdef MR_CHECK_SMALL_GL_ERRORS
    if(mr::MachineInfo::CatchError(0, &gl_er)) {
        std::string err_str = "Error in ShaderUniform::ResetLocation : glGetUniformLocation("+std::to_string(_owner->GetGPUHandle())+", \""+_name+"\") ended with \"" + std::to_string(gl_er) + "\" code. ";
        switch(gl_er) {
        case GL_INVALID_VALUE:
            err_str += "Shader program id is not generated by OpenGL values."; break;
        case GL_INVALID_OPERATION:
            err_str += "id is not an OpenGL program object or program is not successfully linked."; break;
        default:
            err_str += "Unknow code."; break;
        }
        mr::Log::LogString(err_str, MR_LOG_LEVEL_ERROR);
        return false;
    }
#endif

    if(_gpu_location == -1) {
#ifdef MR_CHECK_SMALL_GL_ERRORS
        mr::Log::LogString("Error in ShaderUniform::ResetLocation : glGetUniformLocation("+std::to_string(_owner->GetGPUHandle())+", \""+_name+"\") == -1.", MR_LOG_LEVEL_ERROR);
#endif
        return false;
    }

    OnNewLocation(this, _owner, _gpu_location);

    return true;
}

void ShaderUniform::Update() {
    if(_value) {
#ifdef MR_CHECK_SMALL_GL_ERRORS
    int gl_er = 0;
    mr::gl::ClearError();
#endif
        if(GLEW_EXT_direct_state_access) {
            switch(_type){
            case IShaderUniform::Type::Float:
                glProgramUniform1f(_owner->GetGPUHandle(), _gpu_location, *((float*)_value));
                break;
            case IShaderUniform::Type::Sampler1D:
            case IShaderUniform::Type::Sampler2D:
            case IShaderUniform::Type::Sampler3D:
            case IShaderUniform::Type::Int:
                glProgramUniform1i(_owner->GetGPUHandle(), _gpu_location, *((int*)_value));
                break;
            case IShaderUniform::Type::Mat4:
                glProgramUniformMatrix4fv(_owner->GetGPUHandle(), _gpu_location, 1, false, ((float*)_value));
                break;
            case IShaderUniform::Type::Vec2:
                glProgramUniform2fv(_owner->GetGPUHandle(), _gpu_location, 1, ((float*)_value));
                break;
            case IShaderUniform::Type::Vec3:
                glProgramUniform3fv(_owner->GetGPUHandle(), _gpu_location, 1, ((float*)_value));
                break;
            case IShaderUniform::Type::Vec4:
                glProgramUniform4fv(_owner->GetGPUHandle(), _gpu_location, 1, ((float*)_value));
                break;
            }
        } else {
            switch(_type){
            case IShaderUniform::Type::Float:
                glUniform1f(_gpu_location, *((float*)_value));
                break;
            case IShaderUniform::Type::Sampler1D:
            case IShaderUniform::Type::Sampler2D:
            case IShaderUniform::Type::Sampler3D:
            case IShaderUniform::Type::Int:
                glUniform1i(_gpu_location, *((int*)_value));
            break;
            case IShaderUniform::Type::Mat4:
                glUniformMatrix4fv(_gpu_location, 1, false, ((float*)_value));
                break;
            case IShaderUniform::Type::Vec2:
                glUniform2fv(_gpu_location, 1, ((float*)_value));
                break;
            case IShaderUniform::Type::Vec3:
                glUniform3fv(_gpu_location, 1, ((float*)_value));
                break;
            case IShaderUniform::Type::Vec4:
                glUniform4fv(_gpu_location, 1, ((float*)_value));
                break;
            }
        }
#ifdef MR_CHECK_SMALL_GL_ERRORS
    if(mr::MachineInfo::CatchError(0, &gl_er)) {
        std::string err_str = "Error in ShaderUniform::Update GL \""+ std::to_string(gl_er) + "\" code. ";
        switch(gl_er) {
        case GL_INVALID_VALUE:
            err_str += "Uniform's data is less than zero."; break;
        case GL_INVALID_OPERATION:
            err_str += "No current shader program or uniforms size doesn't match or uniforms type doesn't match or invalid uniform location or bad sampler."; break;
        default:
            err_str += "Unknow code."; break;
        }
        mr::Log::LogString(err_str, MR_LOG_LEVEL_ERROR);
    }
#endif
    }
}

ShaderUniform::ShaderUniform() {
}

ShaderUniform::ShaderUniform
(const std::string& name, const IShaderUniform::Type& type, void* value, IShaderProgram* program)
: _name(name), _gpu_location(-1), _type(type), _value(value), _owner(program) {
    ResetLocation();
}

}
