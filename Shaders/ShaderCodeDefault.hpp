#pragma once
#include <mu/Macro.hpp>

/// RUN 'build_shader_resources.py' to update this

namespace mr {

//BEGIN FILE TO CHAR "BaseShaderVS.glsl"

const char* BaseShaderVS_glsl = "#version 400\n#extension GL_ARB_separate_shader_objects : enable\n#extension GL_NV_shader_buffer_load : enable\n#pragma optimize (on)\n\n/** BUILD CONFIG **/\n#define MR_CUSTOM_INSTANCE_DATA 0\n#define MR_UNIFORM_INSTANCE_DATA 0\n#define MR_USE_ATTRIBUTE_TEXCOORD 1\n#define MR_USE_ATTRIBUTE_NORMAL 1\n#define MR_USE_ATTRIBUTE_COLOR 1\n#define MR_USE_CUSTOM_VERTEX_PROCESSOR 0\n\n/** VERTEX **/\nlayout (location = 0) in vec3 MR_VERTEX_POSITION_ATTRIBUTE;\n#if MR_USE_ATTRIBUTE_TEXCOORD == 1\nlayout (location = 1) in vec2 MR_VERTEX_TEXCOORD_ATTRIBUTE;\n#endif\n#if MR_USE_ATTRIBUTE_NORMAL == 1\nlayout (location = 2) in vec3 MR_VERTEX_NORMAL_ATTRIBUTE;\n#endif\n#if MR_USE_ATTRIBUTE_COLOR == 1\nlayout (location = 3) in vec4 MR_VERTEX_COLOR_ATTRIBUTE;\n#endif\n\n/** PER ENTITY **/\nuniform mat4 MR_MAT_MODEL;\nuniform mat4 MR_MAT_MVP;\n\n/** CAMERA INFO **/\nuniform mat4 MR_MAT_VIEW;\nuniform mat4 MR_MAT_PROJ;\n\n/** INSTANCING **/\n#if MR_CUSTOM_INSTANCE_DATA == 0\nstruct MR_InstanceData {\n    float pos_x;\n    float pos_y;\n    float pos_z;\n};\n#endif\n\n#if MR_UNIFORM_INSTANCE_DATA == 1\nuniform MR_InstanceData* MR_VERTEX_INSTANCED_POSITION;\n#else\nlayout (location = 4) in MR_InstanceData* MR_VERTEX_INSTANCED_POSITION;\n#endif\n\n/** OUTPUT DATA **/\nout vec3 MR_VertexPos;\nout vec3 MR_LocalVertexPos;\n#if MR_USE_ATTRIBUTE_NORMAL == 1\nsmooth out vec3 MR_VertexNormal;\n#endif\nout vec4 MR_VertexColor;\n#if MR_USE_ATTRIBUTE_TEXCOORD == 1\nout vec2 MR_VertexTexCoord;\n#endif\nout vec3 MR_VertexInstancedPos;\n\n/** BUILT-IN FUNCTIONS **/\n\n#define MR_GetInstanceData() MR_VERTEX_INSTANCED_POSITION[gl_InstanceID];\n#define MR_CalcMVP() (MR_MAT_PROJ * MR_MAT_VIEW * MR_MAT_MODEL)\n\n\n/** MAIN **/\n\nvoid main() {\n    MR_InstanceData instanceData = MR_GetInstanceData();\n    vec3 instancePos = vec3(instanceData.pos_x, instanceData.pos_y, instanceData.pos_z);\n    MR_VertexInstancedPos = instancePos;\n\n#if MR_USE_CUSTOM_VERTEX_PROCESSOR == 1\n    /* CUSTOM VERTEX PROCESSOR CODE */\n#else\n    /** DEFAULT VERTEX PROCESSOR **/\n    vec4 realPos = vec4(MR_VERTEX_POSITION_ATTRIBUTE + instancePos, 1.0);\n    vec4 screenPos = MR_CalcMVP() * realPos;\n    gl_Position = screenPos;\n    MR_VertexPos = screenPos.xyz;\n    MR_LocalVertexPos = MR_VERTEX_POSITION_ATTRIBUTE;\n\n#if MR_USE_ATTRIBUTE_NORMAL == 1\n    MR_VertexNormal = (MR_MAT_MODEL * vec4(MR_VERTEX_NORMAL_ATTRIBUTE, 0.0)).xyz;\n#endif\n\n#if MR_USE_ATTRIBUTE_COLOR == 1\n    MR_VertexColor = MR_VERTEX_COLOR_ATTRIBUTE;\n#endif\n\n#if MR_USE_ATTRIBUTE_TEXCOORD == 1\n    MR_VertexTexCoord = MR_VERTEX_TEXCOORD_ATTRIBUTE;\n#endif\n\n#endif //END VERTEX PROCESSOR\n\n}\n";

//END FILE TO CHAR

//BEGIN FILE TO CHAR "BaseShaderFS.glsl"

const char* BaseShaderFS_glsl = "#version 400\n#extension GL_ARB_bindless_texture : require\n#extension GL_NV_gpu_shader5 : enable\n\n#define EPSILON 0.0000001\n\n#define MAX_POINT_LIGHTS 100\n#define MAX_TEXTURES 1000\n\n//precision mediump float;\n\nin vec3 MR_VertexPos;\nin vec3 MR_LocalVertexPos;\nsmooth in vec3 MR_VertexNormal;\nin vec4 MR_VertexColor;\nin vec2 MR_VertexTexCoord;\nin vec3 MR_VertexInstancedPos;\n\nuniform vec3 MR_CAM_POS;\n\nuniform mat4 MR_MAT_MVP;\nuniform mat4 MR_MAT_MODEL;\nuniform mat4 MR_MAT_VIEW;\nuniform mat4 MR_MAT_PROJ;\n\nuniform unsigned int MR_TEX_COLOR;\nuniform unsigned int MR_TEX_NORMAL;\nuniform unsigned int MR_TEX_SPECULAR;\nuniform float MR_TEX_NORMAL_F;\nuniform float MR_TEX_SPECULAR_F;\n\nstruct MR_TextureHandle {\n	uint64_t handle;\n};\n\nlayout(std140) uniform MR_Textures_Block\n{\n    MR_TextureHandle MR_textures[MAX_TEXTURES];\n};\n\nuniform vec4 MR_MATERIAL_COLOR;\n\nout vec4 MR_fragSceneColorNothing;\n\nstruct MR_PointLight {\n   vec3 pos;\n   vec3 color;\n   float innerRange;\n   float outerRange;\n};\n\nuniform int MR_numPointLights;\n\nlayout(std140) uniform MR_pointLights_block\n{\n    MR_PointLight MR_pointLights[MAX_POINT_LIGHTS];\n};\n\nvec2 SphericalTexCoord(in vec3 normal) {\n    float m = 2.0 * sqrt(\n        normal.x*normal.x +\n        normal.y*normal.y +\n        (normal.z + 1.0)*(normal.z + 1.0)\n    );\n    return normal.xy / (m + EPSILON) + vec2(0.5);\n}\n\nvoid GeometryClipSphere(in vec3 pos, in float r) {\n    vec3 surfPos = (MR_MAT_MODEL * vec4(MR_LocalVertexPos,1.0)).xyz + MR_VertexInstancedPos;\n    float inv_dist = 1.0 / (length(surfPos - pos) + EPSILON);\n    float inv_r = 1.0 / r;\n    float il = max(inv_dist, inv_r) - inv_r;\n    il = il / (il + EPSILON); // 1.0 or 0.0\n    if(il <= 0.5) discard;\n}\n\nfloat ZeroOrOne(in float value) {\n    return value / (value + EPSILON);\n}\n\nfloat ScalarInterp(in float x1, in float x2, in float x) {\n    return (x-x1) / (x2-x1 + EPSILON);\n}\n\nvec3 ApplyPointLights(in vec3 surfaceColor, in vec3 surfaceDirection) {\n    vec3 result = vec3(0,0,0);\n    vec3 surfPos = (MR_MAT_MODEL * vec4(MR_LocalVertexPos,1.0)).xyz + MR_VertexInstancedPos;\n    for(int i = 0; i < MR_numPointLights; i++){\n        vec3 lightNormal = normalize(MR_pointLights[i].pos - surfPos);\n        float dist = length(surfPos - MR_pointLights[i].pos);\n        float inv_dist = 1.0 / (dist + EPSILON);\n        float inv_innerR = 1.0 / MR_pointLights[i].innerRange;\n        float innerRangeLight = max(inv_dist, inv_innerR) - inv_innerR;\n        innerRangeLight = ZeroOrOne(innerRangeLight); // 1.0 or 0.0\n        float outerRangeLight = 1.0 - ScalarInterp(MR_pointLights[i].innerRange, MR_pointLights[i].outerRange, dist);\n        float sphereLight = clamp(innerRangeLight + outerRangeLight, 0.0, 1.0);\n        //float backFaceFactor = (dot(surfaceNormal, -lightNormal) + 1.0) / 2.0;\n        float resultLight = sphereLight;\n        //calc normal\n        vec3 normalMap = texture(sampler2D(MR_textures[MR_TEX_NORMAL].handle), MR_VertexTexCoord).rgb;\n        normalMap = mix(vec3(1,1,1), normalMap, MR_TEX_NORMAL_F);\n        vec3 normalMap_ = normalMap * surfaceDirection;\n        vec3 normal = normalMap_;\n\n        //Specular\n        vec3 viewDir = normalize(MR_CAM_POS - surfPos);\n\n        vec3 incidenceVector = -lightNormal; //a unit vector\n        vec3 reflectionVector = reflect(incidenceVector, normal); //also a unit vector\n        float cosAngle = max(0.0, dot(viewDir, reflectionVector));\n        float specularCoefficient = pow(cosAngle, 3.0);\n        float specularMap = mix(0.0, texture(sampler2D(MR_textures[MR_TEX_SPECULAR].handle), MR_VertexTexCoord).r, MR_TEX_SPECULAR_F);\n\n        result += (MR_pointLights[i].color * resultLight * (max(dot(normal, lightNormal), 0.0))) + resultLight * vec3(specularMap * specularCoefficient);\n    }\n    return result * surfaceColor;\n}\n\nvec3 ApplyLights(in vec3 surfaceColor, in vec3 surfaceDirection) {\n    return ApplyPointLights(surfaceColor, surfaceDirection);\n}\n\nvoid main() {\n    vec4 surface_direction = normalize((vec4(MR_VertexNormal,0) * MR_MAT_MODEL));\n    vec3 albedoColor = ApplyLights(texture(sampler2D(MR_textures[MR_TEX_COLOR].handle), MR_VertexTexCoord).xyz, surface_direction.xyz);\n    MR_fragSceneColorNothing = vec4(albedoColor, 1.0);\n}\n";

//END FILE TO CHAR

//This shader code may be changed during runtime
std::string BaseShaderVS_glsl_s = BaseShaderVS_glsl;
std::string BaseShaderFS_glsl_s = BaseShaderFS_glsl;

}
